# CVE-2022-31626 analysis

Some weeks ago researcher with nick [cfreal_](https://twitter.com/cfreal_) reported a bug in PHP mysqlnd package. The vulnerability is heap-based buffer overflow located in function that handles legacy mysql auth method. The bug was patched in PHP 7.4.30 with this commit [https://github.com/php/php-src/commit/58006537fc5f133ae8549efe5118cde418b3ace9](https://github.com/php/php-src/commit/58006537fc5f133ae8549efe5118cde418b3ace9).\
In real web-applications there are some cases where attacker can set arbitrary database server: CMS install scripts or remote database administration scripts. This article considers remote exploitation of this vulnerability in case of simple script for remote database administration.\
Research was done independently of [cfreal\_](https://twitter.com/cfreal_), exploit PoC was [published](https://twitter.com/cyberguru007/status/1539757422490820610) some hours before his talk at Typhoon Con 2022 :)

![](./images/img_0.png)

PoC created for PHP7 configured as Apache2 module. Built with following Configure Command:
<pre> './configure' '--with-bz2' '--with-zlib' '--with-apxs2=/usr/local/apache2.4/bin/apxs' '--with-mysqli=mysqlnd' '--enable-pdo' '--with-pdo-mysql=mysqlnd' '--enable-sockets' '--enable-mbstring' '--with-curl'</pre>

All files can be downloaded here:
- simple web-app [script](./mysql_admin.php)
- [exploit PoC](./exploit_poc.py)
- [script](./rogue_sql_server.py) for rogue Mysql server

Exploit technique summary:
- need only off-by-one heap overflow bug
- prepare heap using POST parsing
- fastbin attack / arbitrary write
- memory leak using zend_string overlap
- code execution with sapi_module overwrite

### Bug analysis

1. At phase of initialization of mysql connection, memory for pfc→cmd\_buffer.buffer is allocated with mnd\_pemalloc function. mnd\_pemalloc allocates memory for persistent connection. File ext/mysqlnd/mysqlnd_protocol_frame_codec.c

![](./images/img_1.png)

![](./images/img_2.png)

![](./images/img_3.png)

If persistent variable is set to 1, pemalloc\_rel uses \_\_zend\_malloc and allocates memory on glibc heap. Different classes/functions for initialization of mysql connection can set persistent flag to 0 or 1. For example, PDO class always sets persistent to 1. By default pfc→cmd\_buffer.length is 0x1000.

2. At phase of authorization process, server sends auth switch packet, to do auth with “mysql\_clear\_password” method. Client accepts it and sends a clear-text password to server. Here the bug happens. File ext/mysqlnd/mysqlnd_wireprotocol.c:

![](./images/img_4.png)

pfc→cmd\_buffer.length is length of buffer allocated by mysqlnd to store auth packet by default it is 0x1000. packet→auth\_data\_len is length of password sent by client. If length of pfc-&gt;cmd\_buffer.buffer is not enough to store received password, new buffer is allocated using mnd\_emalloc. mnd\_emalloc uses memory on PHP heap.

3. 

![](./images/img_5.png)

We want buffer to be located on PHP heap (not glibc heap). For allocating memory with mnd\_malloc, send password with length &gt; 0x1000. Set p pointer to buffer pointer shifter by MYSQLND\_HEADER\_SIZE (4 bytes) and copy packet→auth\_data\_len bytes to it. We overwrite 4 bytes after buffer pointer.\
Note, that fourth byte is always null-byte because client sends null-terminated password string.

### PHP memory manager

To create exploit for heap overflow some knowledge about PHP memory manager can help.\
In PHP 7 allocator, compared to glibc allocator, there is no size/prev\_size metadata for freed blocks, and no forward/backward consolidation.
- To store memory block of small size (less than 3072), PHP uses approach similar to glibc fastbin. Free memory blocks of same size are stored in singly linked list using zend\_mm\_free\_slot structure.

![](./images/img_6.png)

- Memory blocks greater than 3072 bytes are stored on pages. One page is 4096 bytes, memory block can occupy multiple pages, it’s size is rounded to be multiple to page size. Page address is aligned to 0x1000. When storing buffer on multiple pages, last page can have some unused memory. For example memory block with size 0x1f00 takes two pages, last page has 0x100 unused bytes. Pages are stored in a chunk, one chunk has 512 pages.

For more documentation about PHP 7 allocator visit some links [\[1\]](https://github.com/pangudashu/php7-internal/blob/master/5/zend_alloc.md) [\[2\]](https://blog.csdn.net/onlymayao/article/details/104861371).

Use fastbin attack technique for PHP allocator. With the bug we can overwrite at most 4 bytes, fourth byte is always null-byte. next\_free\_block points to next free memory block in linked list and has address like: 0x00007f8b822c9640. We search for a way to build stable exploit without bruteforce, and bypass ASLR. Address overwrite options:
- Rewrite 1 byte:  0x00007f8b822c96**00**   
- Rewrite 2 bytes: 0x00007f8b822c**0041**  
- Rewrite 3 bytes: 0x00007f8b82**004141**  
- Rewrite 4 bytes: 0x00007f8b**00414141**  

We can’t predict address on the server where smallbin page is allocated, so straight forward way to bypass address randomization is to rewrite only one last byte (with null-byte). So we reduce 4-byte overflow into off-by-one overflow.\
Large chunk address is aligned to 0x1000 and size is roundedto be multiple to 0x1000. Last taken page can have some unused memory after buffer, and overflow will write into this unused memory, that gives nothing for attack. To remove the extra space after buffer, we make buffer size multiple to 0x1000. In this case writing beyond buffer writes into next page. 
The only way to rewrite next\_free\_block pointer is to place page allocated for smallbin linked list, exactly right after pages allocated for mysql password, and send password with length that is multiple of the page size. Next step is to prepare PHP heap in the state, where memory block for password will be always allocated right **before** memory block for smallbin.

![](./images/img_7.png)

How to prepare heap for PHP web application? Web application accepts HTTP requests, and does some actions for parsing GET/POST/COOKIE variables.

### Prepare heap using POST parsing

After some debugging, find code lines where memory is allocated for POST vars. PHP does three memory allocations for parsing one POST var. File: php-7.4.29/main/php\_variables.c line 320

![](./images/img_8.png)

This allocation is temporary, after parsing memory block is freed on line 328.\
File: php-7.4.29/ext/filter/filter.c Line 464

![](./images/img_9.png)

And line 474

![](./images/img_10.png)

Two other allocations take memory for POST-variable string.\
Send many POST vars to allocate pages. Code from Python script.

![](./images/img_11.png)  
When POST parsing starts, many smallbins are empty, and taking memory from empty smallbins result in allocation of new pages for smallbin linked lists. File php-7.4.29/Zend/zend\_alloc.c

![](./images/img_12.png)

Send POST vars to take memory from smallbin 12. Memory with sizes 129 to 160 is taken from this bin.

![](./images/img_13.png)

File php-7.4.29/Zend/zend\_alloc\_sizes.h

![](./images/img_14.png)

After allocation of memory for POST vars, we want to free it, and use further for password buffer. We can free taken memory when set again same keys in POST data with other values. Small trick is to overwrite not all variables (free not all taken pages). There is a condition in "for" loop in exploit code. This is done to prepare groups of consecutive free pages - "gaps".

![](./images/img_15.png)

State of chunk pages before POST parsing:

![](./images/img_16.png)

State of chunk pages after POST parsing:

![](./images/img_17.png)

Page marked with red is taken for smallbin 12.\
You can notice that memory allocated for POST variables, placed before this smallbin, is free now. Next stages of PHP script after POST parsing are lexical analysis, Zend VM opcodes compiling. They take some free pages. In our case, the script has \~50 lines of code so it doesn’t take much memory for parsing.\
State of pages right before allocation memory for mysql password:

![](./images/img_18.png)

Now allocate memory for mysql password.

![](./images/img_19.png)

When searching memory for large blocks, PHP7 allocator uses best fit algorithm. Start page is searched to fill the most suitable gap. File php-7.4.29/Zend/zend\_alloc.c

![](./images/img_20.png)

Allocator has “gaps” of free pages with different length (5,2,9,309).

![](./images/img_21.png)

Send password with length 0x8ffd and take “gap” started in page 192 (it has most suitable length, 9 pages).

![](./images/img_22.png)

0x7f6eac6c0004 – buffer pointer\
0x7f6eac6c9000 – smallbin page starts

### Fastbin attack and memory leak

Now we can overwrite last byte of next\_free\_slot with null. Before getting code execution, exploits always do memory leak. To get memory leak we need to modify PHP variable structure in memory. The most suitable structure for this is "zend\_string" [\[3\]](https://www.phpinternalsbook.com/php7/internal_types/strings/zend_strings.html). 

File php-7.4.29/Zend/zend\_types.h:

![](./images/img_23.png)

In PHP7 the string content is appended to the end of zend\_string structure. Overwrite “len” value and output variable with “echo”. Structure overwrite can be achieved with heap overlapping techniques. 

Smallbin is prepared at stage where POST variables are parsed. Remember that when parsing POST data, PHP does two memory allocations for one variable. Send 7 POST variables from 'hi1' to 'hi7' to allocate memory from smallbin. So 7 * 2 = 14 chunks are allocated. After these allocations chunk 15 is free and is a head of Smallbin 12 free list. After 'hi1' var was overwritten in POST with "null", chunk 1 and chunk 2 were freed. Chunk 1 points to chunk 15 (with address 0x7f6eac6c98**c0**). Dump smallbin 12 linked list before heap overflow:

![](./images/img_24.png)

With off-by-one overflow rewrite chunk 1 next_free_slot last byte from c0 to 00. Now chunk 1 points to 0x7f6eac6c98**00**. 

![](./images/img_25.png)

Consider how free blocks are located in memory.

![](./images/img_26.png)

Further taking memory from this smallbin leads to memory allocation at address 0x7f6eac6c9800 and chunk 14 overlap.\

Now we need to take some chunks from smallbin. Don’t forget we have opened mysql connection with a server we fully control. PHP mysqlnd client has many emalloc calls in code that parses answer from server to SELECT command. Just read Mysql protocol description to write rogue mysql server [\[4\]](https://dev.mysql.com/doc/internals/en/com-query-response.html).
File php-7.4.29/ext/mysqlnd/mysqlnd\_wireprotocol.c:

![](./images/img_27.png)

Use ZVAL\_STRINGL macro to allocate memory blocks of any size. Remember, that string data is appended at the end of zend\_string structure. When PHP creates string of N bytes length, it allocates memory for N + 25 bytes. Code from Python exploit:

![](./images/img_28.png)

Allocate memory for zend\_string structure.

![](./images/img_29.png)

Overlap memory block:

![](./images/img_30.png)

zend\_string structure is changed! Now we can leak pointers from heap.

### Getting code execution

Use fastbin attack for arbitrary memory write. Send 5 POST vars from 'hi1' to 'hi5' to allocate chunks 1 to 10 in smallbin. Chunk 11 is head of smallbin free list. Note that 'hi5' variable contains fake chunk structure.

![](./images/img_34.png)

Overwrite some POST vars with 'null' to free memory. Chunk 1 points to free chunk 11.

![](./images/img_37.png)

With off-by-one overflow, overwrite last byte of chunk 1 next_free_slot pointer, from **40** to **00**. Now chunk 1 next_free_slot points to fake chunk structure inside chunk 10. 

![](./images/img_35.png)

Search for pointers to overwrite for getting code execution. Good target is PHP output buffering mechanism. It works every time some data is outputed to web-page (for example, with "echo" or "var_dump") [\[5\]](https://segmentfault.com/a/1190000015836558). In PHP output buffering is done using SAPI modules. Apache2 has it's own SAPI module [\[6\]](https://developpaper.com/in-depth-explain-how-php-and-web-server-interact/), located in file php-7.4.29/sapi/apache2handler/sapi_apache2.c

File php-7.4.29/main/output.c:

![](./images/img_31.png)

If output buffering is not disabled (in case of Apache2), output will be processed by output handler. context.out.data is string passed for output. sapi\_module.ub\_write is callback located in global array. It is a good target for overwrite with "system" address. Prepare fake chunk structure with overwrite address.\

Dump smallbin after off-by-one overwrite:

![](./images/img_36.png)

Do some allocations in Mysql connection to return target address.\
Set breakpoint on php\_output\_op function and see how execution goes.

![](./images/img_33.png)

RCX points to system and RDI has string with bash command. We did it!

### Another heap exploitation approach

![](./images/img_2_1.png)

![](./images/img_2_2.png)

Memory blocks with size larger than 2Mb are named huge chunks.
PHP uses mmap system call when allocates memory for huge chunks, and creates zend_mm_huge_list structure to store information about huge chunk. Size of this structure is 0x18 bytes, and it is placed in smallbin. The structure is inserted into the head of heap→huge_list singly linked list. Unmapping huge chunks with corrupted metadata can lead to overlapping with other chunks. This approach is harder for remote exploitation, but allows to overwrite more data. See more details about this approach [here](https://github.com/CFandR-github/PHP-binary-bugs/tree/main/heap_huge_chunks_overlap).

### References

\[1\] [https://github.com/pangudashu/php7-internal/blob/master/5/zend_alloc.md](https://github.com/pangudashu/php7-internal/blob/master/5/zend_alloc.md)\
\[2\] [https://blog.csdn.net/onlymayao/article/details/104861371](https://blog.csdn.net/onlymayao/article/details/104861371)\
\[3\] [https://www.phpinternalsbook.com/php7/internal_types/strings/zend_strings.html](https://www.phpinternalsbook.com/php7/internal_types/strings/zend_strings.html)\
\[4\] [https://dev.mysql.com/doc/internals/en/com-query-response.html](https://dev.mysql.com/doc/internals/en/com-query-response.html)\
\[5\] [https://segmentfault.com/a/1190000015836558](https://segmentfault.com/a/1190000015836558)\
\[6\] [https://developpaper.com/in-depth-explain-how-php-and-web-server-interact/](https://developpaper.com/in-depth-explain-how-php-and-web-server-interact/)